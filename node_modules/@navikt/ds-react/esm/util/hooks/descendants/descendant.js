/**
 * https://github.com/chakra-ui/chakra-ui/tree/5ec0be610b5a69afba01a9c22365155c1b519136/packages/components/descendant
 */
import { getNextIndex, getPrevIndex, isElement, sortNodes } from "./utils.js";
/**
 * @internal
 *
 * Class to manage descendants and their relative indices in the DOM.
 * It uses `node.compareDocumentPosition(...)` under the hood
 */
export class DescendantsManager {
    constructor() {
        this.descendants = new Map();
        this.register = (nodeOrOptions) => {
            if (nodeOrOptions == null)
                return;
            if (isElement(nodeOrOptions)) {
                return this.registerNode(nodeOrOptions);
            }
            return (node) => {
                this.registerNode(node, nodeOrOptions);
            };
        };
        this.unregister = (node) => {
            this.descendants.delete(node);
            const sorted = sortNodes(Array.from(this.descendants.keys()));
            this.assignIndex(sorted);
        };
        this.destroy = () => {
            this.descendants.clear();
        };
        this.assignIndex = (descendants) => {
            this.descendants.forEach((descendant) => {
                const index = descendants.indexOf(descendant.node);
                descendant.index = index;
                descendant.node.dataset["index"] = descendant.index.toString();
            });
        };
        this.count = () => this.descendants.size;
        this.enabledCount = () => this.enabledValues().length;
        this.values = () => {
            const values = Array.from(this.descendants.values());
            return values.sort((a, b) => a.index - b.index);
        };
        this.enabledValues = () => {
            return this.values().filter((descendant) => !descendant.disabled);
        };
        this.item = (index) => {
            if (this.count() === 0)
                return undefined;
            return this.values()[index];
        };
        this.enabledItem = (index) => {
            if (this.enabledCount() === 0)
                return undefined;
            return this.enabledValues()[index];
        };
        this.first = () => this.item(0);
        this.firstEnabled = () => this.enabledItem(0);
        this.last = () => this.item(this.descendants.size - 1);
        this.lastEnabled = () => {
            const lastIndex = this.enabledValues().length - 1;
            return this.enabledItem(lastIndex);
        };
        this.indexOf = (node) => {
            var _a, _b;
            if (!node)
                return -1;
            return (_b = (_a = this.descendants.get(node)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
        };
        this.enabledIndexOf = (node) => {
            if (node == null)
                return -1;
            return this.enabledValues().findIndex((i) => i.node.isSameNode(node));
        };
        this.next = (index, loop = true) => {
            const next = getNextIndex(index, this.count(), loop);
            return this.item(next);
        };
        this.nextEnabled = (index, loop = true) => {
            const item = this.item(index);
            if (!item)
                return;
            const enabledIndex = this.enabledIndexOf(item.node);
            const nextEnabledIndex = getNextIndex(enabledIndex, this.enabledCount(), loop);
            return this.enabledItem(nextEnabledIndex);
        };
        this.prev = (index, loop = true) => {
            const prev = getPrevIndex(index, this.count() - 1, loop);
            return this.item(prev);
        };
        this.prevEnabled = (index, loop = true) => {
            const item = this.item(index);
            if (!item)
                return;
            const enabledIndex = this.enabledIndexOf(item.node);
            const prevEnabledIndex = getPrevIndex(enabledIndex, this.enabledCount() - 1, loop);
            return this.enabledItem(prevEnabledIndex);
        };
        this.registerNode = (node, options) => {
            if (!node)
                return;
            /**
             * While the node is registered, we have to make sure to sync options
             * This is useful when ex. a node is disabled after it has been registered
             */
            const mapNode = this.descendants.get(node);
            if (mapNode) {
                this.descendants.set(node, Object.assign({ index: mapNode.index, node }, options));
                return;
            }
            const keys = Array.from(this.descendants.keys()).concat(node);
            const sorted = sortNodes(keys);
            if (options === null || options === void 0 ? void 0 : options.disabled) {
                options.disabled = !!options.disabled;
            }
            const descendant = Object.assign({ node, index: -1 }, options);
            this.descendants.set(node, descendant);
            this.assignIndex(sorted);
        };
    }
}
//# sourceMappingURL=descendant.js.map