import cl from "clsx";
import React, { useCallback, useMemo, useState } from "react";
import { createContext } from "../../../util/create-context.js";
import { useClientLayoutEffect, usePrevious } from "../../../util/hooks/index.js";
import { useInputContext } from "../Input/Input.context.js";
import { useSelectedOptionsContext } from "../SelectedOptions/selectedOptionsContext.js";
import { toComboboxOption } from "../combobox-utils.js";
import { useComboboxCustomOptions } from "../customOptionsContext.js";
import filteredOptionsUtils from "./filtered-options-util.js";
import useVirtualFocus from "./useVirtualFocus.js";
const [FilteredOptionsContextProvider, useFilteredOptionsContext] = createContext({
    name: "FilteredOptionsContext",
    errorMessage: "useFilteredOptionsContext must be used within a FilteredOptionsProvider",
});
const FilteredOptionsProvider = ({ children, value: props, }) => {
    const { allowNewValues, filteredOptions: externalFilteredOptions, isListOpen: isExternalListOpen, isLoading, options, } = props;
    const [filteredOptionsRef, setFilteredOptionsRef] = useState(null);
    const virtualFocus = useVirtualFocus(filteredOptionsRef);
    const { inputProps: { "aria-describedby": partialAriaDescribedBy, id }, value, searchTerm, setValue, setSearchTerm, shouldAutocomplete, } = useInputContext();
    const { maxSelected } = useSelectedOptionsContext();
    const [isInternalListOpen, setInternalListOpen] = useState(false);
    const { customOptions } = useComboboxCustomOptions();
    const filteredOptions = useMemo(() => {
        if (externalFilteredOptions) {
            return externalFilteredOptions;
        }
        const opts = [...customOptions, ...options];
        return filteredOptionsUtils.getMatchingValuesFromList(searchTerm, opts);
    }, [customOptions, externalFilteredOptions, options, searchTerm]);
    const previousSearchTerm = usePrevious(searchTerm);
    const [isMouseLastUsedInputDevice, setIsMouseLastUsedInputDevice] = useState(false);
    const filteredOptionsMap = useMemo(() => {
        const initialMap = Object.assign({ [filteredOptionsUtils.getAddNewOptionId(id)]: allowNewValues
                ? toComboboxOption(value)
                : undefined }, customOptions.reduce((acc, customOption) => {
            const _id = filteredOptionsUtils.getOptionId(id, customOption.label);
            acc[_id] = customOption;
            return acc;
        }, {}));
        // Add the options to the map
        const finalMap = options.reduce((map, _option) => {
            const _id = filteredOptionsUtils.getOptionId(id, _option.label);
            map[_id] = _option;
            return map;
        }, initialMap);
        return finalMap;
    }, [allowNewValues, customOptions, id, options, value]);
    useClientLayoutEffect(() => {
        if (shouldAutocomplete &&
            filteredOptionsUtils.normalizeText(searchTerm) !== "" &&
            ((previousSearchTerm === null || previousSearchTerm === void 0 ? void 0 : previousSearchTerm.length) || 0) < searchTerm.length &&
            filteredOptions.length > 0) {
            setValue(`${searchTerm}${filteredOptions[0].label.substring(searchTerm.length)}`);
            setSearchTerm(searchTerm);
        }
    }, [
        filteredOptions,
        previousSearchTerm,
        searchTerm,
        setSearchTerm,
        setValue,
        shouldAutocomplete,
    ]);
    const isListOpen = useMemo(() => {
        return isExternalListOpen !== null && isExternalListOpen !== void 0 ? isExternalListOpen : isInternalListOpen;
    }, [isExternalListOpen, isInternalListOpen]);
    const toggleIsListOpen = useCallback((newState) => {
        virtualFocus.moveFocusToTop();
        setInternalListOpen((oldState) => newState !== null && newState !== void 0 ? newState : !oldState);
    }, [virtualFocus]);
    const isValueNew = useMemo(() => Boolean(value) &&
        !filteredOptionsMap[filteredOptionsUtils.getOptionId(id, value)], [filteredOptionsMap, id, value]);
    const ariaDescribedBy = useMemo(() => {
        let activeOption = "";
        if (!isLoading && filteredOptions.length === 0 && !allowNewValues) {
            activeOption = filteredOptionsUtils.getNoHitsId(id);
        }
        else if (value || isLoading) {
            if (shouldAutocomplete && filteredOptions[0]) {
                activeOption = filteredOptionsUtils.getOptionId(id, filteredOptions[0].label);
            }
            else if (isListOpen && isLoading) {
                activeOption = filteredOptionsUtils.getIsLoadingId(id);
            }
        }
        const maybeMaxSelectedOptionsId = (maxSelected === null || maxSelected === void 0 ? void 0 : maxSelected.isLimitReached) &&
            filteredOptionsUtils.getMaxSelectedOptionsId(id);
        return (cl(activeOption, maybeMaxSelectedOptionsId, partialAriaDescribedBy) ||
            undefined);
    }, [
        isListOpen,
        isLoading,
        maxSelected === null || maxSelected === void 0 ? void 0 : maxSelected.isLimitReached,
        value,
        partialAriaDescribedBy,
        shouldAutocomplete,
        filteredOptions,
        id,
        allowNewValues,
    ]);
    const currentOption = useMemo(() => { var _a; return filteredOptionsMap[((_a = virtualFocus.activeElement) === null || _a === void 0 ? void 0 : _a.getAttribute("id")) || -1]; }, [filteredOptionsMap, virtualFocus]);
    const activeDecendantId = useMemo(() => { var _a; return ((_a = virtualFocus.activeElement) === null || _a === void 0 ? void 0 : _a.getAttribute("id")) || undefined; }, [virtualFocus.activeElement]);
    const filteredOptionsState = {
        activeDecendantId,
        allowNewValues,
        setFilteredOptionsRef,
        shouldAutocomplete,
        isListOpen,
        isLoading,
        filteredOptions,
        isMouseLastUsedInputDevice,
        setIsMouseLastUsedInputDevice,
        isValueNew,
        toggleIsListOpen,
        currentOption,
        virtualFocus,
        ariaDescribedBy,
    };
    return (React.createElement(FilteredOptionsContextProvider, Object.assign({}, filteredOptionsState), children));
};
export { FilteredOptionsProvider, useFilteredOptionsContext };
//# sourceMappingURL=filteredOptionsContext.js.map