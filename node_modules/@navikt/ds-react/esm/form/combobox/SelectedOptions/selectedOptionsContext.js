import React, { useCallback, useMemo, useState } from "react";
import { createContext } from "../../../util/create-context.js";
import { usePrevious } from "../../../util/hooks/index.js";
import { useInputContext } from "../Input/Input.context.js";
import { isInList } from "../combobox-utils.js";
import { useComboboxCustomOptions } from "../customOptionsContext.js";
const [SelectedOptionsContextProvider, useSelectedOptionsContext] = createContext();
const SelectedOptionsProvider = ({ children, value, }) => {
    const { clearInput, focusInput } = useInputContext();
    const { customOptions, removeCustomOption, addCustomOption, setCustomOptions, } = useComboboxCustomOptions();
    const { allowNewValues, isMultiSelect, selectedOptions: externalSelectedOptions, onToggleSelected, options, maxSelected, } = value;
    const [internalSelectedOptions, setSelectedOptions] = useState([]);
    const selectedOptions = useMemo(() => externalSelectedOptions !== null && externalSelectedOptions !== void 0 ? externalSelectedOptions : [...customOptions, ...internalSelectedOptions], [customOptions, externalSelectedOptions, internalSelectedOptions]);
    const addSelectedOption = useCallback((option) => {
        const isCustomOption = !isInList(option, options);
        if (isCustomOption) {
            allowNewValues && addCustomOption(option);
            !isMultiSelect && setSelectedOptions([]);
        }
        else if (isMultiSelect) {
            setSelectedOptions((oldSelectedOptions) => [
                ...oldSelectedOptions,
                option,
            ]);
        }
        else {
            setSelectedOptions([option]);
            setCustomOptions([]);
        }
        onToggleSelected === null || onToggleSelected === void 0 ? void 0 : onToggleSelected(option.value, true, isCustomOption);
    }, [
        addCustomOption,
        allowNewValues,
        isMultiSelect,
        onToggleSelected,
        options,
        setCustomOptions,
    ]);
    const removeSelectedOption = useCallback((option) => {
        const isCustomOption = isInList(option, customOptions);
        if (isCustomOption) {
            removeCustomOption(option);
        }
        else {
            setSelectedOptions((oldSelectedOptions) => oldSelectedOptions.filter((selectedOption) => selectedOption !== option));
        }
        onToggleSelected === null || onToggleSelected === void 0 ? void 0 : onToggleSelected(option.value, false, isCustomOption);
    }, [customOptions, onToggleSelected, removeCustomOption]);
    const toggleOption = useCallback((option, event) => {
        if (isInList(option.value, selectedOptions)) {
            removeSelectedOption(option);
        }
        else {
            addSelectedOption(option);
        }
        clearInput(event);
        focusInput();
    }, [
        addSelectedOption,
        clearInput,
        focusInput,
        removeSelectedOption,
        selectedOptions,
    ]);
    const prevSelectedOptions = usePrevious(selectedOptions);
    const isLimitReached = !!(maxSelected === null || maxSelected === void 0 ? void 0 : maxSelected.limit) && selectedOptions.length >= maxSelected.limit;
    const selectedOptionsState = {
        addSelectedOption,
        isMultiSelect,
        removeSelectedOption,
        prevSelectedOptions,
        selectedOptions,
        setSelectedOptions,
        toggleOption,
        maxSelected: maxSelected && Object.assign(Object.assign({}, maxSelected), { isLimitReached }),
    };
    return (React.createElement(SelectedOptionsContextProvider, Object.assign({}, selectedOptionsState), children));
};
export { SelectedOptionsProvider, useSelectedOptionsContext };
//# sourceMappingURL=selectedOptionsContext.js.map