import React from "react";
export const coordsAreInside = ({ clientX, clientY }, { left, top, right, bottom }) => {
    if (clientX < left || clientY < top)
        return false;
    if (clientX > right || clientY > bottom)
        return false;
    return true;
};
export function getCloseHandler(modalRef, header, onBeforeClose) {
    if (header && header.closeButton === false)
        return undefined;
    if (onBeforeClose) {
        return () => { var _a; return onBeforeClose() !== false && ((_a = modalRef.current) === null || _a === void 0 ? void 0 : _a.close()); };
    }
    return () => { var _a; return (_a = modalRef.current) === null || _a === void 0 ? void 0 : _a.close(); };
}
export const BODY_CLASS = "navds-modal__document-body";
export function useBodyScrollLock(modalRef, portalNode, isNested) {
    React.useEffect(() => {
        if (isNested)
            return;
        if (!modalRef.current || !portalNode)
            return; // We check both to avoid running this twice when not using portal
        if (modalRef.current.open)
            document.body.classList.add(BODY_CLASS); // In case `open` is true initially
        const observer = new MutationObserver(() => {
            var _a;
            if ((_a = modalRef.current) === null || _a === void 0 ? void 0 : _a.open)
                document.body.classList.add(BODY_CLASS);
            else
                document.body.classList.remove(BODY_CLASS);
        });
        observer.observe(modalRef.current, {
            attributes: true,
            attributeFilter: ["open"],
        });
        return () => {
            observer.disconnect();
            document.body.classList.remove(BODY_CLASS); // In case modal is unmounted before it's closed
        };
    }, [modalRef, portalNode, isNested]);
}
//# sourceMappingURL=ModalUtils.js.map