"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDate = exports.INPUT_DATE_STRING_FORMAT_MONTH = exports.INPUT_DATE_STRING_FORMAT_DATE = void 0;
const date_fns_1 = require("date-fns");
const check_dates_1 = require("./check-dates");
exports.INPUT_DATE_STRING_FORMAT_DATE = "dd.MM.yyyy";
exports.INPUT_DATE_STRING_FORMAT_MONTH = "MMMM yyyy";
const ALLOWED_INPUT_FORMATS_DATE = [
    exports.INPUT_DATE_STRING_FORMAT_DATE,
    "ddMMyyyy",
    "dd/MM/yyyy",
    "dd-MM-yyyy",
];
const ALLOWED_INPUT_FORMATS_MONTH = [
    "M/yyyy",
    "MM/yyyy",
    "M-yyyy",
    "MM-yyyy",
    "MM.yyyy",
    exports.INPUT_DATE_STRING_FORMAT_MONTH,
    ...ALLOWED_INPUT_FORMATS_DATE,
];
const parseDate = (date, today, locale, type, allowTwoDigitYear) => {
    let parsed;
    const ALLOWED_FORMATS = type === "date" ? ALLOWED_INPUT_FORMATS_DATE : ALLOWED_INPUT_FORMATS_MONTH;
    if (allowTwoDigitYear) {
        for (const format of ALLOWED_FORMATS) {
            parsed = (0, date_fns_1.parse)(date, format, today, { locale });
            if ((0, check_dates_1.isValidDate)(parsed) &&
                !isTwoDigitYear(date, today, locale, ALLOWED_FORMATS)) {
                return parsed;
            }
        }
        for (const format of [
            ...ALLOWED_FORMATS.map((x) => x.replace("yyyy", "yy")),
        ]) {
            parsed = (0, date_fns_1.parse)(date, format, today, { locale });
            if ((0, check_dates_1.isValidDate)(parsed) &&
                isTwoDigitYear(date, today, locale, ALLOWED_FORMATS)) {
                const convertedDate = assignCenturyToDate(date, format, today, locale);
                if ((0, check_dates_1.isValidDate)(new Date(convertedDate))) {
                    return new Date(convertedDate);
                }
                return new Date("Invalid date");
            }
        }
        return new Date("Invalid date");
    }
    for (const format of ALLOWED_FORMATS) {
        parsed = (0, date_fns_1.parse)(date, format, today, { locale });
        if ((0, check_dates_1.isValidDate)(parsed) &&
            !isTwoDigitYear(date, today, locale, ALLOWED_FORMATS)) {
            return parsed;
        }
    }
    return new Date("Invalid date");
};
exports.parseDate = parseDate;
function isTwoDigitYear(dateString, today, locale, formats) {
    let parsed;
    const newFormat = formats.map((x) => x.replace("yyyy", "yy"));
    for (const format of newFormat) {
        parsed = (0, date_fns_1.parse)(dateString, format, today, { locale });
        if ((0, check_dates_1.isValidDate)(parsed)) {
            return true;
        }
    }
    return false;
}
function assignCenturyToDate(dateStr, format, today, locale) {
    const date20Century = (0, date_fns_1.parse)(appendCenturyToTwoYearDigitDateString(dateStr, "19"), format.replace("yy", "yyyy"), today, { locale });
    const date21Century = (0, date_fns_1.parse)(appendCenturyToTwoYearDigitDateString(dateStr, "20"), format.replace("yy", "yyyy"), today, { locale });
    if ((0, check_dates_1.isValidDate)(date20Century) && (0, check_dates_1.isValidDate)(date21Century)) {
        return (0, date_fns_1.isBefore)(date20Century, (0, date_fns_1.sub)(new Date(), {
            years: 80,
        }))
            ? date21Century
            : date20Century;
    }
    return new Date("Invalid date");
}
function appendCenturyToTwoYearDigitDateString(dateString, century) {
    const twoDigitYear = dateString.slice(-2);
    return `${dateString.slice(0, dateString.length - 2)}${century}${twoDigitYear}`;
}
//# sourceMappingURL=parse-date.js.map