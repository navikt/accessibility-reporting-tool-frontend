"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useToggleItem = void 0;
const react_1 = require("react");
const composeEventHandlers_1 = require("../../util/composeEventHandlers");
const useMergeRefs_1 = require("../../util/hooks/useMergeRefs");
const ToggleGroup_context_1 = require("../ToggleGroup.context");
function useToggleItem({ value, disabled = false, onFocus: _onFocus, onClick, onKeyDown: _onKeyDown, }, ref) {
    const { setSelectedValue, setFocusedValue, selectedValue, focusedValue } = (0, ToggleGroup_context_1.useToggleGroupContext)();
    const { register, descendants } = (0, ToggleGroup_context_1.useToggleGroupDescendant)({
        disabled,
        value,
    });
    const isSelected = value === selectedValue;
    const onFocus = () => setFocusedValue(value);
    /**
     * Implements roving-tabindex for horizontal tabs
     */
    const onKeyDown = (0, react_1.useCallback)((event) => {
        /**
         * ToggleGroup.Item is registered with its prop 'value'.
         * We can then use it to find the current focuses descendant
         */
        const idx = descendants
            .values()
            .findIndex((x) => x.value === focusedValue);
        const nextTab = () => {
            var _a;
            const next = descendants.nextEnabled(idx, false);
            next && ((_a = next.node) === null || _a === void 0 ? void 0 : _a.focus());
        };
        const prevTab = () => {
            var _a;
            const prev = descendants.prevEnabled(idx, false);
            prev && ((_a = prev.node) === null || _a === void 0 ? void 0 : _a.focus());
        };
        const firstTab = () => {
            var _a;
            const first = descendants.firstEnabled();
            first && ((_a = first.node) === null || _a === void 0 ? void 0 : _a.focus());
        };
        const lastTab = () => {
            var _a;
            const last = descendants.lastEnabled();
            last && ((_a = last.node) === null || _a === void 0 ? void 0 : _a.focus());
        };
        const keyMap = {
            ArrowLeft: prevTab,
            ArrowRight: nextTab,
            Home: firstTab,
            End: lastTab,
        };
        const action = keyMap[event.key];
        if (action) {
            event.preventDefault();
            action(event);
        }
        else if (event.key === "Tab") {
            /**
             * Imperative focus during keydown is risky so we prevent React's batching updates
             * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332
             */
            selectedValue && setTimeout(() => setFocusedValue(selectedValue));
        }
    }, [descendants, focusedValue, selectedValue, setFocusedValue]);
    return {
        ref: (0, useMergeRefs_1.mergeRefs)([register, ref]),
        isSelected,
        isFocused: focusedValue === value,
        onClick: (0, composeEventHandlers_1.composeEventHandlers)(onClick, () => setSelectedValue(value)),
        onFocus: disabled ? undefined : (0, composeEventHandlers_1.composeEventHandlers)(_onFocus, onFocus),
        onKeyDown: (0, composeEventHandlers_1.composeEventHandlers)(_onKeyDown, onKeyDown),
    };
}
exports.useToggleItem = useToggleItem;
//# sourceMappingURL=useToggleItem.js.map