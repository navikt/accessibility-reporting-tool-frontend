/**
 * @module
 * This module is the base module for the Hono object.
 */
import { Context } from './context';
import type { ExecutionContext } from './context';
import type { Router } from './router';
import type { Env, ErrorHandler, H, HandlerInterface, MergePath, MergeSchemaPath, MiddlewareHandlerInterface, NotFoundHandler, OnHandlerInterface, RouterRoute, Schema } from './types';
/**
 * Symbol used to mark a composed handler.
 */
export declare const COMPOSED_HANDLER: unique symbol;
type GetPath<E extends Env> = (request: Request, options?: {
    env?: E['Bindings'];
}) => string;
export type HonoOptions<E extends Env> = {
    /**
     * `strict` option specifies whether to distinguish whether the last path is a directory or not.
     * @default true
     * @see https://hono.dev/api/hono#strict-mode
     */
    strict?: boolean;
    /**
     * `router` option specifices which router to use.
     * ```ts
     * const app = new Hono({ router: new RegExpRouter() })
     * ```
     * @see https://hono.dev/api/hono#router-option
     */
    router?: Router<[H, RouterRoute]>;
    /**
     * `getPath` can handle the host header value.
     * @example
     * ```ts
     * const app = new Hono({
     *  getPath: (req) =>
     *   '/' + req.headers.get('host') + req.url.replace(/^https?:\/\/[^/]+(\/[^?]*)/, '$1'),
     * })
     *
     * app.get('/www1.example.com/hello', () => c.text('hello www1'))
     *
     * // A following request will match the route:
     * // new Request('http://www1.example.com/hello', {
     * //  headers: { host: 'www1.example.com' },
     * // })
     * ```
     * @see https://hono.dev/api/routing#routing-with-host-header-value
     */
    getPath?: GetPath<E>;
};
declare class Hono<E extends Env = Env, S extends Schema = {}, BasePath extends string = '/'> {
    #private;
    get: HandlerInterface<E, 'get', S, BasePath>;
    post: HandlerInterface<E, 'post', S, BasePath>;
    put: HandlerInterface<E, 'put', S, BasePath>;
    delete: HandlerInterface<E, 'delete', S, BasePath>;
    options: HandlerInterface<E, 'options', S, BasePath>;
    patch: HandlerInterface<E, 'patch', S, BasePath>;
    all: HandlerInterface<E, 'all', S, BasePath>;
    on: OnHandlerInterface<E, S, BasePath>;
    use: MiddlewareHandlerInterface<E, S, BasePath>;
    router: Router<[H, RouterRoute]>;
    readonly getPath: GetPath<E>;
    private _basePath;
    routes: RouterRoute[];
    constructor(options?: HonoOptions<E>);
    private clone;
    private notFoundHandler;
    private errorHandler;
    route<SubPath extends string, SubEnv extends Env, SubSchema extends Schema, SubBasePath extends string>(path: SubPath, app?: Hono<SubEnv, SubSchema, SubBasePath>): Hono<E, MergeSchemaPath<SubSchema, MergePath<BasePath, SubPath>> & S, BasePath>;
    /**
     * `.basePath()` allows base paths to be specified.
     * @example
     * ```ts
     * const api = new Hono().basePath('/api')
     * ```
     * @see https://hono.dev/api/routing#base-path
     */
    basePath<SubPath extends string>(path: SubPath): Hono<E, S, MergePath<BasePath, SubPath>>;
    /**
     * `.onError()` handles an error and returns a customized Response.
     * ```ts
     * app.onError((err, c) => {
     *   console.error(`${err}`)
     *   return c.text('Custom Error Message', 500)
     * })
     * ```
     */
    onError: (handler: ErrorHandler<E>) => Hono<E, S, BasePath>;
    /**
     * `.notFound()` allows you to customize a Not Found Response.
     * ```ts
     * app.notFound((c) => {
     *   return c.text('Custom 404 Message', 404)
     * })
     * ```
     * @see https://hono.dev/api/hono#not-found
     */
    notFound: (handler: NotFoundHandler<E>) => Hono<E, S, BasePath>;
    /**
     * Mounts an external application handler to the specified path.
     *
     * @param path - The path where the external application handler should be mounted.
     * @param applicationHandler - The external application handler function that processes requests.
     * @param optionHandler - Optional function to handle additional options, such as environment variables and execution context.
     *
     * @returns The current instance of Hono for chaining.
     *
     * @example
     * ```ts
     * const app = new Hono()
     * const externalAppHandler = () => new Response('External App')
     * app.mount('/external', externalAppHandler)
     * ```
     * @see https://hono.dev/api/hono#mount
     */
    mount(path: string, applicationHandler: (request: Request, ...args: any) => Response | Promise<Response>, optionHandler?: (c: Context) => unknown): Hono<E, S, BasePath>;
    private addRoute;
    private matchRoute;
    private handleError;
    private dispatch;
    /**
     * `.fetch()` will be entry point of your app.
     * @see https://hono.dev/api/hono#fetch
     */
    fetch: (request: Request, Env?: E['Bindings'] | {}, executionCtx?: ExecutionContext) => Response | Promise<Response>;
    /**
     * `.request()` is a useful method for testing.
     * You can pass a URL or pathname to send a GET request.
     * app will return a Response object.
     * ```ts
     * test('GET /hello is ok', async () => {
     *   const res = await app.request('/hello')
     *   expect(res.status).toBe(200)
     * })
     * ```
     * @see https://hono.dev/api/hono#request
     */
    request: (input: RequestInfo | URL, requestInit?: RequestInit, Env?: E['Bindings'] | {}, executionCtx?: ExecutionContext) => Response | Promise<Response>;
    /**
     * `.fire()` automatically adds a global fetch event listener.
     * This can be useful for environments that adhere to the Service Worker API, such as non-ES module Cloudflare Workers.
     * @see https://hono.dev/api/hono#fire
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
     * @see https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/
     */
    fire: () => void;
}
export { Hono as HonoBase };
